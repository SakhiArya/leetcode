Key attributes
1) An alternative way to implement Binary Search
2) Search Condition needs to access element's immediate left and right neighbors
3) Use element's neighbors to determine if condition is met and decide whether to go left or right
4) Gurantees Search Space is at least 3 in size at each step
5) Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition.

Distinguishing Syntax 

1) Initial Condition: left = 0, right = length-1
2) Termination: left + 1 == right
3) Searching Left: right = mid
4) Searching Right: left = mid



int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}